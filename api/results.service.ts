/**
 * NeoLoad API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ArrayOfElementDefinition } from '../model/arrayOfElementDefinition';
import { ArrayOfEventDefinition } from '../model/arrayOfEventDefinition';
import { ArrayOfSLAGlobalIndicatorDefinition } from '../model/arrayOfSLAGlobalIndicatorDefinition';
import { ArrayOfSLAPerIntervalDefinition } from '../model/arrayOfSLAPerIntervalDefinition';
import { ArrayOfSLAPerTestDefinition } from '../model/arrayOfSLAPerTestDefinition';
import { ArrayOfTestDefinition } from '../model/arrayOfTestDefinition';
import { CounterDefinition } from '../model/counterDefinition';
import { CounterDefinitionArray } from '../model/counterDefinitionArray';
import { CounterValues } from '../model/counterValues';
import { ElementDefinition } from '../model/elementDefinition';
import { ElementValues } from '../model/elementValues';
import { EventType } from '../model/eventType';
import { MonitorPostRequest } from '../model/monitorPostRequest';
import { Points } from '../model/points';
import { RateLimitError } from '../model/rateLimitError';
import { Sla } from '../model/sla';
import { TestDefinition } from '../model/testDefinition';
import { TestRasterConfiguration } from '../model/testRasterConfiguration';
import { TestRasterMultiConfiguration } from '../model/testRasterMultiConfiguration';
import { TestStatistics } from '../model/testStatistics';
import { TestUpdateRequest } from '../model/testUpdateRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ResultsService {

    protected basePath = '/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Deletes a test result
     * Deletes a test result and all the associated statistics. This action cannot be undone.
     * @param testId Unique identifier representing a specific test.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTest(testId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTest(testId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTest(testId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTest(testId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling deleteTest.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test result description
     * Provides a test result description using a unique test identifier. Provides name, dates, owner ...
     * @param testId Unique identifier representing a specific test.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTest(testId: string, observe?: 'body', reportProgress?: boolean): Observable<TestDefinition>;
    public getTest(testId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TestDefinition>>;
    public getTest(testId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TestDefinition>>;
    public getTest(testId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTest.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TestDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test element definition
     * Provides a test element definition.
     * @param testId Unique identifier representing a specific test.
     * @param elementId Unique identifier representing a specific element.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestElementDefinition(testId: string, elementId: string, observe?: 'body', reportProgress?: boolean): Observable<ElementDefinition>;
    public getTestElementDefinition(testId: string, elementId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ElementDefinition>>;
    public getTestElementDefinition(testId: string, elementId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ElementDefinition>>;
    public getTestElementDefinition(testId: string, elementId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestElementDefinition.');
        }

        if (elementId === null || elementId === undefined) {
            throw new Error('Required parameter elementId was null or undefined when calling getTestElementDefinition.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ElementDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/elements/${encodeURIComponent(String(elementId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test elements
     * Provides the tests elements of a test result. The elements type must be provided.
     * @param testId Unique identifier representing a specific test.
     * @param category Category of the elements to return.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestElements(testId: string, category: string, observe?: 'body', reportProgress?: boolean): Observable<ArrayOfElementDefinition>;
    public getTestElements(testId: string, category: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArrayOfElementDefinition>>;
    public getTestElements(testId: string, category: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArrayOfElementDefinition>>;
    public getTestElements(testId: string, category: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestElements.');
        }

        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling getTestElements.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArrayOfElementDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/elements`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Tests elements points since the beginning of the test
     * Provides all the ponits of a test element for the selected statistics.
     * @param testId Unique identifier representing a specific test.
     * @param elementId Unique identifier representing a specific element.
     * @param statistics Comma-separated list of statistics to get. Available statistics are: AVG_DURATION (ms), MIN_DURATION (ms), MAX_DURATION (ms), COUNT, THROUGHPUT (Byte/s), ELEMENTS_PER_SECOND, ERRORS, ERRORS_PER_SECOND, ERROR_RATE (%), AVG_TTFB (ms), MIN_TTFB (ms), MAX_TTFB (ms).&lt;br/&gt; Example: AVG_DURATION,ELEMENTS_PER_SECOND
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestElementsPoints(testId: string, elementId: string, statistics: string, observe?: 'body', reportProgress?: boolean): Observable<Points>;
    public getTestElementsPoints(testId: string, elementId: string, statistics: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Points>>;
    public getTestElementsPoints(testId: string, elementId: string, statistics: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Points>>;
    public getTestElementsPoints(testId: string, elementId: string, statistics: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestElementsPoints.');
        }

        if (elementId === null || elementId === undefined) {
            throw new Error('Required parameter elementId was null or undefined when calling getTestElementsPoints.');
        }

        if (statistics === null || statistics === undefined) {
            throw new Error('Required parameter statistics was null or undefined when calling getTestElementsPoints.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (statistics !== undefined && statistics !== null) {
            queryParameters = queryParameters.set('statistics', <any>statistics);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Points>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/elements/${encodeURIComponent(String(elementId))}/points`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test elements SLA status since the beginning of the test
     * Provides the SLA status of a test element.
     * @param testId Unique identifier representing a specific test.
     * @param elementId Unique identifier representing a specific element.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestElementsSla(testId: string, elementId: string, observe?: 'body', reportProgress?: boolean): Observable<Sla>;
    public getTestElementsSla(testId: string, elementId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Sla>>;
    public getTestElementsSla(testId: string, elementId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Sla>>;
    public getTestElementsSla(testId: string, elementId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestElementsSla.');
        }

        if (elementId === null || elementId === undefined) {
            throw new Error('Required parameter elementId was null or undefined when calling getTestElementsSla.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Sla>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/elements/${encodeURIComponent(String(elementId))}/sla`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test elements values
     * Provides the values of a test element.
     * @param testId Unique identifier representing a specific test.
     * @param elementId Unique identifier representing a specific element.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestElementsValues(testId: string, elementId: string, observe?: 'body', reportProgress?: boolean): Observable<ElementValues>;
    public getTestElementsValues(testId: string, elementId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ElementValues>>;
    public getTestElementsValues(testId: string, elementId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ElementValues>>;
    public getTestElementsValues(testId: string, elementId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestElementsValues.');
        }

        if (elementId === null || elementId === undefined) {
            throw new Error('Required parameter elementId was null or undefined when calling getTestElementsValues.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ElementValues>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/elements/${encodeURIComponent(String(elementId))}/values`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Tests events
     * List the events of the specified test according to the method parameters.
     * @param testId Unique identifier representing a specific test.
     * @param types The types of the events you expect to get. It will return all the types if the field is left empty. (Ctrl+click to select multiple values) 
     * @param limit The maximum number of elements returned by this call. The maximum must be less than or equal to 200.
     * @param offset The offset of the first element to return. Starting at this offset, the query will return a maximum of &#x27;limit&#x27; elements.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestEvents(testId: string, types?: Array<EventType>, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<ArrayOfEventDefinition>;
    public getTestEvents(testId: string, types?: Array<EventType>, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArrayOfEventDefinition>>;
    public getTestEvents(testId: string, types?: Array<EventType>, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArrayOfEventDefinition>>;
    public getTestEvents(testId: string, types?: Array<EventType>, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestEvents.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (types) {
            queryParameters = queryParameters.set('types', types.join(COLLECTION_FORMATS['csv']));
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArrayOfEventDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/events`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test Graph
     * Provides a graph from some stats of a test result.
     * @param testId Unique identifier representing a specific test.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestGraph(testId: string, body?: TestRasterConfiguration, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getTestGraph(testId: string, body?: TestRasterConfiguration, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getTestGraph(testId: string, body?: TestRasterConfiguration, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getTestGraph(testId: string, body?: TestRasterConfiguration, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestGraph.');
        }


        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'image/png',
            'image/jpeg',
            'image/tiff',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Blob>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/graph`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Tests counter definition
     * Provides the definition of a test counter.
     * @param testId Unique identifier representing a specific test.
     * @param counterId Unique identifier representing a specific counter.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestMonitorDefinition(testId: string, counterId: string, observe?: 'body', reportProgress?: boolean): Observable<CounterDefinition>;
    public getTestMonitorDefinition(testId: string, counterId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CounterDefinition>>;
    public getTestMonitorDefinition(testId: string, counterId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CounterDefinition>>;
    public getTestMonitorDefinition(testId: string, counterId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestMonitorDefinition.');
        }

        if (counterId === null || counterId === undefined) {
            throw new Error('Required parameter counterId was null or undefined when calling getTestMonitorDefinition.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CounterDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/monitors/${encodeURIComponent(String(counterId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test monitors
     * Provides all the tests counters of all monitors for a test result.
     * @param testId Unique identifier representing a specific test.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestMonitors(testId: string, observe?: 'body', reportProgress?: boolean): Observable<CounterDefinitionArray>;
    public getTestMonitors(testId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CounterDefinitionArray>>;
    public getTestMonitors(testId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CounterDefinitionArray>>;
    public getTestMonitors(testId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestMonitors.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CounterDefinitionArray>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/monitors`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Tests monitors points
     * Provides all the points of a test counter. The values are the average on the specified interval.
     * @param testId Unique identifier representing a specific test.
     * @param counterId Unique identifier representing a specific counter.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestMonitorsPoints(testId: string, counterId: string, observe?: 'body', reportProgress?: boolean): Observable<Points>;
    public getTestMonitorsPoints(testId: string, counterId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Points>>;
    public getTestMonitorsPoints(testId: string, counterId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Points>>;
    public getTestMonitorsPoints(testId: string, counterId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestMonitorsPoints.');
        }

        if (counterId === null || counterId === undefined) {
            throw new Error('Required parameter counterId was null or undefined when calling getTestMonitorsPoints.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Points>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/monitors/${encodeURIComponent(String(counterId))}/points`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Tests monitors values
     * Provides the values of a test counter.
     * @param testId Unique identifier representing a specific test.
     * @param counterId Unique identifier representing a specific counter.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestMonitorsValues(testId: string, counterId: string, observe?: 'body', reportProgress?: boolean): Observable<CounterValues>;
    public getTestMonitorsValues(testId: string, counterId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CounterValues>>;
    public getTestMonitorsValues(testId: string, counterId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CounterValues>>;
    public getTestMonitorsValues(testId: string, counterId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestMonitorsValues.');
        }

        if (counterId === null || counterId === undefined) {
            throw new Error('Required parameter counterId was null or undefined when calling getTestMonitorsValues.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CounterValues>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/monitors/${encodeURIComponent(String(counterId))}/values`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test MultiGraph
     * Provides a graph from some stats of some tests result.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestMultiGraph(body?: TestRasterMultiConfiguration, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getTestMultiGraph(body?: TestRasterMultiConfiguration, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getTestMultiGraph(body?: TestRasterMultiConfiguration, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getTestMultiGraph(body?: TestRasterMultiConfiguration, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'image/png',
            'image/jpeg',
            'image/tiff',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Blob>(`${this.basePath}/tests/graph`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * SLAs global indicators
     * Provides the SLAs global indicators of the test result.
     * @param testId Unique identifier representing a specific test.
     * @param status The status of the element you expect to get the SLA for. It will return all the statuses if the field is left empty.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestSLAGlobalIndicators(testId: string, status?: string, observe?: 'body', reportProgress?: boolean): Observable<ArrayOfSLAGlobalIndicatorDefinition>;
    public getTestSLAGlobalIndicators(testId: string, status?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArrayOfSLAGlobalIndicatorDefinition>>;
    public getTestSLAGlobalIndicators(testId: string, status?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArrayOfSLAGlobalIndicatorDefinition>>;
    public getTestSLAGlobalIndicators(testId: string, status?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestSLAGlobalIndicators.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArrayOfSLAGlobalIndicatorDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/slas/statistics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * SLAs per time interval
     * Provides the SLAs per time interval of a specific test result.
     * @param testId Unique identifier representing a specific test.
     * @param status The status of the element you expect to get the SLA for. It will return all the statuses if the field is left empty.
     * @param category The category of the element you expect to get the SLA for. It will return all the categories if the field is left empty.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestSLAPerInterval(testId: string, status?: string, category?: string, observe?: 'body', reportProgress?: boolean): Observable<ArrayOfSLAPerIntervalDefinition>;
    public getTestSLAPerInterval(testId: string, status?: string, category?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArrayOfSLAPerIntervalDefinition>>;
    public getTestSLAPerInterval(testId: string, status?: string, category?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArrayOfSLAPerIntervalDefinition>>;
    public getTestSLAPerInterval(testId: string, status?: string, category?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestSLAPerInterval.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArrayOfSLAPerIntervalDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/slas/per-interval`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * SLAs per test
     * Provides the SLAs per test of a specific test result.
     * @param testId Unique identifier representing a specific test.
     * @param status The status of the element you expect to get the SLA for. It will return all the statuses if the field is left empty.
     * @param category The category of the element you expect to get the SLA for. It will return all the categories if the field is left empty.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestSLAPerTest(testId: string, status?: string, category?: string, observe?: 'body', reportProgress?: boolean): Observable<ArrayOfSLAPerTestDefinition>;
    public getTestSLAPerTest(testId: string, status?: string, category?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArrayOfSLAPerTestDefinition>>;
    public getTestSLAPerTest(testId: string, status?: string, category?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArrayOfSLAPerTestDefinition>>;
    public getTestSLAPerTest(testId: string, status?: string, category?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestSLAPerTest.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (category !== undefined && category !== null) {
            queryParameters = queryParameters.set('category', <any>category);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArrayOfSLAPerTestDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/slas/per-test`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Test result main statistics
     * Provides the main statistics of a test result. For a runnning test, these statistics are live, for a finished test, those are average for the all test.
     * @param testId Unique identifier representing a specific test.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTestStatistics(testId: string, observe?: 'body', reportProgress?: boolean): Observable<TestStatistics>;
    public getTestStatistics(testId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TestStatistics>>;
    public getTestStatistics(testId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TestStatistics>>;
    public getTestStatistics(testId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling getTestStatistics.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TestStatistics>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/statistics`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lists test results
     * Lists the test results of the Account according to the method parameters.
     * @param status Returns only the test with the specified status.
     * @param project Project name. Returns only the tests of the specified project.
     * @param author The author of the test. Returns only the tests launched by the specified author.
     * @param limit The maximum number of elements returned by this call. The maximum must be less than or equal to 200.
     * @param offset The offset of the first element to return. Starting at this offset, the query will return a maximum of &#x27;limit&#x27; elements.
     * @param fields Comma-separated list of fields to include in the json test definition.
     * @param pretty If true the Json returned is human readable.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTests(status?: string, project?: string, author?: string, limit?: number, offset?: number, fields?: string, pretty?: boolean, observe?: 'body', reportProgress?: boolean): Observable<ArrayOfTestDefinition>;
    public getTests(status?: string, project?: string, author?: string, limit?: number, offset?: number, fields?: string, pretty?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArrayOfTestDefinition>>;
    public getTests(status?: string, project?: string, author?: string, limit?: number, offset?: number, fields?: string, pretty?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArrayOfTestDefinition>>;
    public getTests(status?: string, project?: string, author?: string, limit?: number, offset?: number, fields?: string, pretty?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (status !== undefined && status !== null) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (project !== undefined && project !== null) {
            queryParameters = queryParameters.set('project', <any>project);
        }
        if (author !== undefined && author !== null) {
            queryParameters = queryParameters.set('author', <any>author);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (fields !== undefined && fields !== null) {
            queryParameters = queryParameters.set('fields', <any>fields);
        }
        if (pretty !== undefined && pretty !== null) {
            queryParameters = queryParameters.set('pretty', <any>pretty);
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ArrayOfTestDefinition>(`${this.basePath}/tests`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create custom monitors
     * Pushes monitoring data (external data) for a given running test. &lt;br/&gt;&lt;br/&gt; &lt;b&gt;Resolution limitation&lt;/b&gt;: &lt;ul&gt;   &lt;li&gt;Maximum resolution for a monitor value is &lt;b&gt;1 per second&lt;/b&gt;, otherwise &lt;b&gt;the first value is kept&lt;/b&gt;.&lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Maximum paths and monitors&lt;/b&gt;: &lt;ul&gt;   &lt;li&gt;Maximum 100 different &lt;b&gt;unique&lt;/b&gt; paths.&lt;/li&gt;   &lt;li&gt;Maximum 50 different monitors for a given path.&lt;/li&gt;   &lt;li&gt;Maximum length is 10 for a path.&lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Other requirements&lt;/b&gt;: &lt;ul&gt;   &lt;li&gt;&#x27;/&#x27; character is not allowed in path element.&lt;/li&gt;   &lt;li&gt;The test must be &lt;b&gt;running&lt;/b&gt; while pushing the data.&lt;/li&gt;   &lt;li&gt;For a given timestamp, all monitors relative to a path must be sent in the same request.&lt;/li&gt;   &lt;li&gt;These elements must not be empty: &lt;b&gt;monitor name&lt;/b&gt;, &lt;b&gt;a path element&lt;/b&gt; and &lt;b&gt;values&lt;/b&gt;.&lt;/li&gt; &lt;/ul&gt; 
     * @param body List of custom monitors
     * @param testId Unique identifier representing a specific test.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTestMonitors(body: MonitorPostRequest, testId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postTestMonitors(body: MonitorPostRequest, testId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postTestMonitors(body: MonitorPostRequest, testId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postTestMonitors(body: MonitorPostRequest, testId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postTestMonitors.');
        }

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling postTestMonitors.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}/monitors`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a test result
     * Updates a test result with new name, description or quality status.
     * @param body 
     * @param testId Unique identifier representing a specific test.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTest(body: TestUpdateRequest, testId: string, observe?: 'body', reportProgress?: boolean): Observable<TestDefinition>;
    public updateTest(body: TestUpdateRequest, testId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TestDefinition>>;
    public updateTest(body: TestUpdateRequest, testId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TestDefinition>>;
    public updateTest(body: TestUpdateRequest, testId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTest.');
        }

        if (testId === null || testId === undefined) {
            throw new Error('Required parameter testId was null or undefined when calling updateTest.');
        }

        let headers = this.defaultHeaders;

        // authentication (NeoloadAuthorizer) required
        if (this.configuration.apiKeys["accountToken"]) {
            headers = headers.set('accountToken', this.configuration.apiKeys["accountToken"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TestDefinition>(`${this.basePath}/tests/${encodeURIComponent(String(testId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
